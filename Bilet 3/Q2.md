Сигналы в системах семейства Unix.


Из Иртегова [733+]
Unix профессиональное программирование (На русском) [377 +]
man signal
man sigaction
Irtegov-OS-Unix-System-Calls [241+]


* Два типа:
	* Надёжные
	* Ненадёжные
	* Они несовместимы между собой
* [[cигнал]] метод асинхронной (не только) связи между [[Ядро]] и [[Процесс]] (или процесс - процесс).  
* Сигнал генерируется в ядре и может быть отправлен только через него
* Два класса (Из книги иртегова)
	- синхронные (т. е. возникающие в момент исполнения программой определенной операции, например деления на ноль): SIGFPE, SIGSEGV, SIGPIPE
	- асинхронные (т. е. возникающие из-за внешних по отношению к программе событий): SIGINT, SIGHUP, SIGALARM
 * Причины отправления сигналов:
	 * Сигналы, генерируемые терминалом, возникают, когда пользователь вводит определенные символы. (CTR_C - SIGINT)
	 * Аппаратные ошибки — деление на 0, ошибка доступа к памяти и прочее
	 * Функция kill(2) позволяет процессу передать любой сигнал другому процессу или группе процессов. необходимо быть владельцем процесса, которому посылается сигнал, или обладать привилегиями суперпользователя
	 * Команда kill(1) позволяет передавать сигналы другим процессам
	 * Сигналы могут порождаться при условиях, определяемых программно, например, когда нужно известить приложение о наступлении некоторого события. Эти условия определяются не аппаратурой (как, например, деление на 0), а программным обеспечением.
		 * SIGPIPE
		 * SIGALARM
	* raise
* Сигналы являют собой классический пример асинхронных событий. Сигнал может быть передан процессу в любой момент. 
* Существует способ получать сигнал синхронно путём блокировки выполнения до получения сигнала (https://www.man7.org/linux/man-pages/man7/signal.7.html или man signal(7))
	*  sigwaitinfo(2), sigtimedwait(2), and sigwait(3)
	*  signalfd(2)
* Установка обработчика
	* void (*signal(int signo, void (*func)(int)))(int) - устаревшая, может быть не совместима с разными unix'ами (man signal)
		* Функция signal определена стандартом ISO C, который ничего не говорит о многозадачности, группах процессов, терминальном вводе/выводе и т.п. Поэтому определение сигналов в этом стандарте практически бесполезно для систем UNIX
		* с ним ассоциированы ненадёжные сигналы
	* int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); - поддерживается posix'ом (man sigaction)
		* с ним ассоциирован надёжные сигналы
* Маски
	* [[Процесс]] имеет атрибут, называемый маской сигналов (signal mask). Этот атрибут представляет собой битовую маску, в которой каждому типу сигнала соответствует один бит
	* Маска проверяется при каждой попытке доставить сигнал; если соответствующий бит установлен, то сигнал не доставляется — ни установленный программой, ни системный обработчики не вызываются, системные вызовы не прерываются, но, в отличие от игнорируемых сигналов, информация о сигнале сохраняется: когда бит в маске будет сброшен, сигнал будет доставлен (Ровно один сигнал)
* Обработка ошибок
	* Главной проблемой простых обработчиков ошибок является недостаточность знаний обработчика о контексте исполнения основной нити программы. Эта проблема в довольно широких пределах может решаться за счет того, что регистрация обработчика ошибки — это, в сущности, дешевая операция, которая просто сводится к записи указателя на функцию-обработчик в определенную таблицу
	* таким образом, каждый из возможных обработчиков может знать, из какого места программы он может быть вызван; если соответствующий объем кода невелик, можно даже с достаточно высокой достоверностью определить, в каком именно месте кода возникла данная ошибка.
	* Более того, с каждым сигналом может быть ассоциирован [[siginfo_t]]
*  Блокирующийся [[системный вызов]]
	* Если в момент возникновения сигнала процесс исполнял блокирующийся системный вызов, этот системный вызов прерывается. Таким образом, если во время возникновения сигнала исполнялся системный вызов, то управление будет передано в его точку возврата; при этом код возврата будет сигнализировать об ошибке, а значение _errno_ будет равно _EINTR_. Если разработчик программы все-таки желает исполнить системный вызов, он должен проверить код ошибки и, если он равен _EINTR_, повторить вызов с теми же параметрами.
	* Современные версии системы, такие как BSD 4.3 и старше, System V Release 4, при установке обработчика сигнала позволяют задать флаг, требующий **автоматического перезапуска** прерванных этим сигналом системных вызовов.
	* ![[Pasted image 20231226192756.png]]
	* Стандарт POSIX.1 требует от реализаций перезапускать системные вызовы, только
когда для прерывающего сигнала действует флаг SA_RESTART.
*  SIG_IGN (Игнорирование)
	* Вместо обработчика можно также зарегистрировать "функции" SIG_DFL и SIG_IGN. Эти "функции" представляют собой численные значения, приведенные к типу указателя на функцию. SIG_IGN (от IGNore (да ладно)) обозначает игнорирование сигнала; при возникновении соответствующего события ничего не происходит, никакие обработчики не вызываются, системные вызовы не прерываются, информации о пришедшем сигнале не сохраняется.
	* SIGKILL и SIGSTOP, нельзя игнорировать
	* если проигнорировать некоторые из сигналов, возникающих в результате аппаратных ошибок (таких, как деление на 0 или попытка обращения к несуществующей памяти), поведение процесса может стать непредсказуемым
	
* SIG_DFL (DeFauLt, по умолчанию (спасибо)) соответствует системному обработчику по умолчанию; 
	* для разных сигналов эти обработчики, вообще говоря, различны, но их общая номенклатура не так уж широка.
	* Для большинства сигналов обработка по умолчанию состоит в завершении процесса. Для некоторых сигналов, таких как SIGFPE и SIGSEGV, процесс завершается с созданием посмертного дампа памяти. дамп создается в текущем каталоге в файле с именем [[core]] (современные системы, в зависимости от настроек, могут добавлять к core идентификатор процесса или другую информацию).
	* Группа сигналов, реакция на которые состоит в остановке процесса: SIGTSTP, SIGSTOP, SIGTTIN, SIGTTOUT, SIGTRAP. Процесс, остановленный такими сигналами, не завершается, но приостанавливается. Чтобы возобновить его исполнение, необходимо послать ему сигнал SIGCONT.
	* ![[Pasted image 20231226183630.png]]
	* ![[Pasted image 20231226183646.png]]
	* ![[Pasted image 20231226183720.png]]
	* ![[Pasted image 20231226183743.png]]
	* ![[Pasted image 20231226183756.png]]
	* ![[Pasted image 20231226183816.png]]
	* ![[Pasted image 20231226183827.png]]
* Обработчик ([signal handler])
	* Сигнал происходит в произвольные моменты по отношению к основной нити программы, поэтому актуальны все многопоточные проблемы
		* В обработчике можно использовать только функции описанные в 'man signal-safety'
		* Стандарт Single UNIX Specification определяет перечень функций, которые должны обеспечивать безопасность вызова из обработчиков сигналов. Эти функции являются реентерабельными и в стандарте Single UNIX Specification называются безопасными для использования в обработчиках асинхронных сигналов
		* Если мы хотим сохранить ERRNO, то стоит сохранить его копию в начале обработчика и вернуть прежнее значение в конце
		* Иртегов пишет, что основное средство решения - маскирование сигналов. (Иногда может возникнуть потребность заблокировать сигнал, то есть не игнорировать его, а просто отложить посылку сигнала до момента, когда приложение будет готово принять его)
		* Общий вид обработчиков (в sigaction):
			* void     (*sa_handler)(int);
			* void     (*sa_sigaction)(int, siginfo_t *, void *);
			* они могут быть [[union]] в зависимости от системы, поэтому следует выбирать только один из них 
		* Бывают ситуации, когда прибывший сигнал может влиять на правильность исполнения программы, если возникнет в неправильном месте кода. Одно решение состоит в игнорировании сигналов в этой критической секции, но при использовании такого метода сигналы могут быть потеряны. Более удачный метод состоит в том, чтобы задержать сигналы до момента, когда программа будет готова прореагировать на сигнал. Вызов sighold(2) должен стоять перед входом в [[критическая секция]], а вызов sigrelse(2) должен быть сделан после выхода из него.
* ## Ещё про надёжные сигналы
* Интервал времени между генерацией сигнала и его доставкой называется периодом ожидания обработки
* Что произойдет, если заблокированный сигнал будет сгенерирован несколько раз, прежде чем процесс разблокирует его? Стандарт POSIX.1 допускает доставку как единственного сигнала, так и всех сгенерированных сигналов. Если система доставляет процессу все сгенерированные сигналы, мы говорим, что сигналы ставятся в очередь. Однако большинство версий UNIX при отсутствии расширений реального времени POSIX.1 не ставят сигналы в очередь, то есть ядро доставляет единственный сигнал
* Что произойдет, если сразу несколько сигналов одновременно будут готовы к доставке? Стандарт POSIX.1 не определяет порядок доставки сигналов. Однако POSIX.1 Rationale предлагает в первую очередь доставлять сигналы, которые  имеют отношение к текущему состоянию процесса (SIGSEGV)
* ### Ещё про ненадёжные 
	* Сигналы могли теряться: иными словами, процесс мог не получить посланный ему сигнал
